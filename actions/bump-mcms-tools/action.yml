name: "Bump mcms-tools version"
description: "Detect latest mcms-tools release and update workflow inputs"

inputs:
  github_token:
    description: "Token for GitHub API (gh cli)"
    required: true
  mcms_repo:
    description: "Repo to read releases from (owner/name)"
    required: false
    default: "smartcontractkit/mcms-tools"
  workflows_regex:
    description:
      "Regex pattern to match workflow files to update (can live under any
      directory)"
    required: false
    default: ".*/\\.github/workflows/.*\\.(yml|yaml)$"
  action_uses_pattern:
    description: "String to match the composite action step (prefix of uses:)"
    required: false
    default: "smartcontractkit/.github/actions/get-mcms-tools@"
  version_input_path:
    description: "The YAML path to the input (relative to the step) to set"
    required: false
    default: "with.version"

outputs:
  latest_tag:
    description: "Latest mcms-tools release tag"
    value: ${{ steps.latest.outputs.tag }}
  changed:
    description: "true if any file changed, false otherwise"
    value: ${{ steps.update.outputs.changed }}

runs:
  using: "composite"
  steps:
    - name: Check out
      uses: actions/checkout@v4

    - name: Install yq
      uses: dcarbone/install-yq-action@3b5b9f8b5d98b7d7e4cf94337336e414a2d79a8b # v1.3.1
      with:
        version: v4

    - name: Resolve latest tag
      id: latest
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        GITHUB_TOKEN: ${{ inputs.github_token }}
        MCMS_REPO: ${{ inputs.mcms_repo }}
      run: |
        set -euo pipefail

        echo "Fetching most recent non-draft release from $MCMS_REPO"
        TAG=$(gh api "repos/$MCMS_REPO/releases" --paginate \
          --jq '[.[] | select(.draft==false)][0].tag_name')

        if [[ -z "${TAG:-}" || "${TAG}" == "null" ]]; then
          echo "No non-draft releases found in $MCMS_REPO" >&2
          exit 1
        fi

        echo "Latest tag discovered: $TAG"
        echo "tag=$TAG" | tee -a "$GITHUB_OUTPUT"

    - name: Update workflow files
      id: update
      shell: bash
      env:
        LATEST: ${{ steps.latest.outputs.tag }}
        PATTERN: ${{ inputs.action_uses_pattern }} # e.g. smartcontractkit/.github/actions/get-mcms-tools@
        VERSION_KEY: ${{ inputs.version_input_path }} # e.g. with.version
        WORKFLOWS_REGEX: ${{ inputs.workflows_regex }}
      run: |
        set -Eeuo pipefail
        IFS=$'\n\t'

        changed=false

        sha1() {
          if command -v sha1sum >/dev/null 2>&1; then
            sha1sum "$1" | awk '{print $1}'
          elif command -v shasum >/dev/null 2>&1; then
            shasum -a 1 "$1" | awk '{print $1}'
          else
            echo "error: no sha1sum or shasum found" >&2
            exit 1
          fi
        }

        # Build a safe regex for yq's test() — anchor to beginning.
        # Escape chars meaningful to regex: []^$.*+?(){}|\ 
        esc_for_regex() { sed -E 's/([][\^$.|?*+(){}])/\\\1/g' ; }
        PATTERN_REGEX="^$(printf '%s' "$PATTERN" | esc_for_regex)"

        # yq programs (v4 syntax)
        make_query_expr() {
          printf '(.jobs[]?.steps[]? | select((.uses // "") | type == "!!str" and (.uses | test("%s"))) | %s) // empty' \
            "$PATTERN_REGEX" "$VERSION_KEY"
        }
        make_dump_expr() {
          printf '[.jobs[]? as $j ireduce ({}; .) | $j.steps[]? | select((.uses // "") | type == "!!str" and (.uses | test("%s"))) | {id, name, uses, version: (%s // "<missing>")}]' \
            "$PATTERN_REGEX" "$VERSION_KEY"
        }
        make_patch_expr() {
          printf '(.jobs[]?.steps[]? | select((.uses // "") | type == "!!str" and (.uses | test("%s"))) | %s) = "%s"' \
            "$PATTERN_REGEX" "$VERSION_KEY" "$LATEST"
        }

        query_expr="$(make_query_expr)"
        dump_expr="$(make_dump_expr)"
        patch_expr="$(make_patch_expr)"

        # Grep prefilter for visibility
        esc_grep_pat="$(printf '%s' "$PATTERN" | sed -E 's/[][\.^$*+?(){}|/]/\\&/g')"

        echo "::group::Discovery"
        echo "Effective workflows regex: $WORKFLOWS_REGEX"
        echo "Action uses pattern: $PATTERN"
        echo "YQ test() regex: $PATTERN_REGEX"
        echo "grep prefilter: uses:\\s*['\"]?${esc_grep_pat}"
        echo "Version key path: $VERSION_KEY"
        mapfile -d '' files < <(find . -regextype posix-extended -regex "$WORKFLOWS_REGEX" -type f -print0 || true)
        total_files=${#files[@]}
        echo "Files matched by regex: $total_files"
        for f in "${files[@]}"; do echo "  - $f"; done
        echo "::endgroup::"

        if [[ $total_files -eq 0 ]]; then
          echo "No workflow files matched regex."
          echo "changed=$changed" | tee -a "$GITHUB_OUTPUT"
          exit 0
        fi

        updated_count=0
        matched_files=0
        already_latest_count=0
        skipped_no_match=0
        yq_errors=0

        for f in "${files[@]}"; do
          echo "::group::Analyze $f"

          if grep -Eq "uses:\\s*['\"]?${esc_grep_pat}" "$f"; then
            echo "Prefilter: found 'uses:' lines referencing the action:"
            grep -En "uses:\\s*['\"]?${esc_grep_pat}.*" "$f" || true
          else
            echo "Prefilter: no 'uses:' lines referencing the action → skip"
            echo "::endgroup::"
            skipped_no_match=$((skipped_no_match+1))
            continue
          fi

          echo "Matched steps (pre-update):"
          # dump_expr returns JSON array of objects
          yq -o=json "$dump_expr" "$f" || true

          current_versions="$(yq -r "$query_expr" "$f" 2>/dev/null || true)"
          if [[ -n "$current_versions" ]]; then
            matched_files=$((matched_files+1))
            unique_versions="$(printf "%s\n" "$current_versions" | sed '/^$/d' | sort -u)"
            match_count=$(printf "%s\n" "$unique_versions" | wc -l | tr -d ' ')
            echo "Existing '$VERSION_KEY' values: $match_count"
            while read -r v; do
              [[ -n "$v" ]] && echo "  - $v"
            done <<< "$unique_versions"
          else
            echo "No existing '$VERSION_KEY' found on matched steps (will set it to $LATEST)."
          fi

          echo "Target version: $LATEST"

          before=$(sha1 "$f")
          if ! yq -i "$patch_expr" "$f"; then
            echo "yq error updating file; leaving unchanged."
            echo "::endgroup::"
            yq_errors=$((yq_errors+1))
            continue
          fi
          after=$(sha1 "$f")

          if [[ "$before" != "$after" ]]; then
            echo "Status: UPDATED → set to $LATEST"
            changed=true
            updated_count=$((updated_count+1))
          else
            echo "Status: ALREADY LATEST (no changes)"
            already_latest_count=$((already_latest_count+1))
          fi

          echo "Matched steps (post-update):"
          yq -o=json "$dump_expr" "$f" || true

          echo "::endgroup::"
        done

        echo "::group::Summary"
        echo "Files scanned:        $total_files"
        echo "Files updated:        $updated_count"
        echo "Already at latest:    $already_latest_count"
        echo "No matching steps:    $skipped_no_match"
        echo "yq errors:            $yq_errors"
        echo "::endgroup::"

        echo "changed=$changed" | tee -a "$GITHUB_OUTPUT"
