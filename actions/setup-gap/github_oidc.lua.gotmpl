-- Load the JSON library for decoding JSON payloads
JSON = (loadfile "/etc/envoy/json.lua")() -- One-time load of the routines

-- Variables to store JWT token and its expiration time
local jwt_expiration = 0
local jwt_token = nil
local refreshing = false -- Flag to prevent concurrent token refreshes
local request_options = { ["asynchronous"] = true }
local main_dns_zone = "{{ getenv "MAIN_DNS_ZONE" }}"
local escaped_main_dns_zone = main_dns_zone:gsub("[%.%+%*%?%^%$%(%)%%]", "%%%1")

-- Constants for headers
local GITHUB_OIDC_TOKEN_HEADER = "{{ getenv "GITHUB_OIDC_TOKEN_HEADER_NAME" }}"
local GITHUB_REPOSITORY_HEADER = "x-repository"

-- Log prefix (will be updated dynamically)
log_prefix = "local-proxy: LUA:: "

-- Function to decode base64 value
local function decode_base64(input)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    input = input:gsub('[^' .. b .. '=]', '') -- Remove invalid characters

    return (input:gsub('.', function(x)
        if x == '=' then
            return '' -- Ignore padding characters
        end
        local r, f = '', (b:find(x) - 1)
        for i = 6, 1, -1 do
            r = r .. (f % 2 ^ i - f % 2 ^ (i - 1) > 0 and '1' or '0') -- Convert to binary
        end
        return r
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if #x ~= 8 then
            return '' -- Skip incomplete bytes
        end
        local c = 0
        for i = 1, 8 do
            c = c + (x:sub(i, i) == '1' and 2 ^ (8 - i) or 0) -- Convert binary to decimal
        end
        return string.char(c) -- Convert decimal to ASCII character
    end))
end

-- Function to get JWT expiration time from JWT token
local function get_jwt_exp(jwt)
    -- Extract the three parts of the JWT: header, payload, and signature
    local header, payload, signature = jwt:match("([^%.]+)%.([^%.]+)%.([^%.]+)")
    if not (header and payload and signature) then
        return nil -- Invalid JWT format
    end

    -- Decode the payload from Base64
    local decoded_payload = decode_base64(payload)
    if not decoded_payload then
        return nil -- Failed to decode payload
    end

    -- Parse the decoded payload as JSON
    local decoded_json = JSON.decode(decoded_payload)
    if not decoded_json or not decoded_json.exp then
        return nil -- Missing expiration time in payload
    end

    return decoded_json.exp -- Return the expiration time
end

-- Function to fetch GitHub OIDC token
function fetch_github_oidc_token(request_handle)
    if refreshing then
        request_handle:logDebug(log_prefix .. "Token refresh already in progress, skipping new fetch.")
        return -- Prevent multiple concurrent refreshes
    end
    refreshing = true
    request_handle:logDebug(log_prefix .. "Starting GitHub OIDC token fetch.")

    -- The GitHub OIDC token URL and token are pulled from environment variables at template render time
    local audience = "gap"
    local oidc_url = "{{ getenv "ACTIONS_ID_TOKEN_REQUEST_URL" }}&audience=" .. audience

    -- Prepare headers for the HTTP request - these values come from environment variables
    local headers = {
        [":method"] = "GET",
        [":path"] = oidc_url,
        [":authority"] = "{{ getenv "GITHUB_OIDC_HOSTNAME" }}",
        ["Authorization"] = "Bearer {{ getenv "ACTIONS_ID_TOKEN_REQUEST_TOKEN" }}",
        ["accept"] = "application/json",
    }

    -- Make the HTTP call to fetch the OIDC token
    local response_headers, response_body
    local success, err = pcall(function()
        response_headers, response_body = request_handle:httpCall(
            "github_oidc_endpoint",
            headers,
            nil, -- No body for GET requests
            5000 -- Timeout in milliseconds
        )
        return true
    end)

    if not success then
        request_handle:logErr(log_prefix .. "Error fetching GitHub OIDC token: " .. tostring(err))
        refreshing = false
        return
    end

    if response_headers[":status"] == "200" then
        request_handle:logInfo(log_prefix .. "GitHub OIDC token fetched successfully.")
        -- Try-catch for JSON parsing
        local success, data = pcall(function() 
            return JSON.decode(response_body)
        end)

        if success and data and data.value then
            jwt_token = data.value -- Store the token
            jwt_expiration = get_jwt_exp(jwt_token) or (os.time() + 300) -- Use token exp or 5 minutes
            request_handle:logDebug(log_prefix .. "Fetched JWT length: " .. string.len(jwt_token))
        else
            request_handle:logErr(log_prefix .. "Failed to parse OIDC token response: " .. tostring(response_body))
        end
    else
        request_handle:logErr(log_prefix .. "Failed to fetch GitHub OIDC token. Status: " .. 
                            (response_headers[":status"] or "unknown") ..
                            " Body: " .. (response_body or ""))
    end

    refreshing = false -- Reset the refreshing flag
end

-- Function to refresh the token if needed
function refresh_token_if_needed(request_handle)
    local current_time = os.time()
    -- Refresh the token if it's missing or about to expire (within 60 seconds)
    if not jwt_token or jwt_expiration - current_time < 60 then
        request_handle:logDebug(log_prefix .. "Token missing or expiring soon. Refreshing token.")
        fetch_github_oidc_token(request_handle)
    else
        request_handle:logDebug(log_prefix .. "Token is valid. No refresh needed.")
    end
end

-- Function to ensure that the host header's port will be 443
local function ensure_port_443(request_handle)
    local host = request_handle:headers():get(":authority")
    if host and host:find(escaped_main_dns_zone .. ":%d+$") then
        request_handle:headers():remove(":authority")
        local new_host = host:gsub(":%d+$", ":443")
        request_handle:headers():add(":authority", new_host)
        request_handle:logDebug(log_prefix .. "Updated :authority header to force port 443: " .. new_host)
    end
end

-- Function to add headers to the request
local function add_headers(request_handle)
    -- Ensure no null or empty x-repository header exists
    local repoHeader = request_handle:headers():get(GITHUB_REPOSITORY_HEADER)
    if not repoHeader or repoHeader == "" then
        request_handle:headers():remove(GITHUB_REPOSITORY_HEADER)
        request_handle:headers():add(GITHUB_REPOSITORY_HEADER, "{{ getenv "GITHUB_REPOSITORY" }}")
        request_handle:logDebug(log_prefix .. "x-repository header was null or empty. Added default x-repository header.")
    else
        request_handle:logDebug(log_prefix .. "x-repository header already present: " .. tostring(repoHeader))
    end

    -- Remove the existing OIDC token header if present
    request_handle:headers():remove(GITHUB_OIDC_TOKEN_HEADER)
    -- Add the new JWT token to the header (do not log the token value itself)
    request_handle:headers():add(GITHUB_OIDC_TOKEN_HEADER, "Bearer " .. jwt_token)
    request_handle:logInfo(log_prefix .. "Added GitHub JWT OIDC token with length: " .. string.len(jwt_token) ..
                             " to header: " .. GITHUB_OIDC_TOKEN_HEADER)

    -- Ensure that the host header's port will be 443
    ensure_port_443(request_handle)

    -- Prepare complete request information for logging
    local request_info = {
        method = request_handle:headers():get(":method"),
        scheme = request_handle:headers():get(":scheme"),
        authority = request_handle:headers():get(":authority"),
        path = request_handle:headers():get(":path"),
        headers = {}
    }

    -- Add all headers to the request info, redacting sensitive values
    for key, value in pairs(request_handle:headers():toTable()) do
        if key == GITHUB_OIDC_TOKEN_HEADER then
            request_info.headers[key] = "[REDACTED - LENGTH: " .. string.len(value) .. "]"
        else
            request_info.headers[key] = value
        end
    end

    -- Log the complete request information
    request_handle:logDebug(log_prefix .. "Final upstream request: " .. JSON.encode(request_info))
end

-- Main function for Envoy request interception
function envoy_on_request(request_handle)
    local host = request_handle:headers():get(":authority") or ""
    local path = request_handle:headers():get(":path") or ""
    local user_agent = request_handle:headers():get("user-agent") or "unknown"
    
    request_handle:logDebug(log_prefix .. "Processing request: " .. host .. path .. " from " .. user_agent)

    -- Set repository header once at the beginning (avoiding duplication with add_headers)
    local repoHeader = request_handle:headers():get(GITHUB_REPOSITORY_HEADER)
    if not repoHeader or repoHeader == "" then
        request_handle:headers():remove(GITHUB_REPOSITORY_HEADER)
        request_handle:headers():add(GITHUB_REPOSITORY_HEADER, "{{ getenv "GITHUB_REPOSITORY" }}")
        request_handle:logDebug(log_prefix .. "Pre-check: Added default x-repository header for user-agent: " .. user_agent)
    end

    -- Determine if we need to add auth token (apply to all potentially authenticated requests)
    local needs_auth = false
    
    -- Check authentication patterns:
    -- 1. All paths starting with /ethereum
    -- 2. All hosts in the main DNS zone (*.main.prod.cldev.sh)
    -- 3. Special paths/hosts configured in the system
    if path:find("^/ethereum/") or 
       host:find(escaped_main_dns_zone .. "$") or 
       host:find(escaped_main_dns_zone .. ":%d+$") or 
       host:find("^gap%-") or
       host:find("^localhost") then
        needs_auth = true
    end

    if needs_auth then
        -- Refresh the token if necessary
        refresh_token_if_needed(request_handle)

        -- Only proceed if we have a valid token
        if not jwt_token then
            request_handle:logErr(log_prefix .. "No valid JWT token available for request: " .. host .. path)
            return  -- Stop processing this request
        end

        -- Add required headers (including JWT token)
        add_headers(request_handle)
    else
        request_handle:logDebug(log_prefix .. "Skipping auth for non-authenticated path: " .. host .. path)
    end

    -- Final safety checks and logging (no need for duplicate header check)
    if needs_auth and (not request_handle:headers():get(GITHUB_OIDC_TOKEN_HEADER)) then
        request_handle:logErr(log_prefix .. "Final validation failed: Missing auth token for: " .. host .. path)
        -- Emergency token addition as last resort
        if jwt_token then
            request_handle:headers():remove(GITHUB_OIDC_TOKEN_HEADER)
            request_handle:headers():add(GITHUB_OIDC_TOKEN_HEADER, "Bearer " .. jwt_token)
        end
    end

    request_handle:logDebug(log_prefix .. "Request processing complete: " .. host .. path)
end
