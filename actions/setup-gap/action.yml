name: setup-gap
description: "Setup GitHub Actions Proxy (GAP)"

inputs:
  # General inputs
  gap-name:
    description:
      "The name of the GAP. Used in the dir name for self-signed certs and the
      docker container name."
    required: false
    default: "default"
  ca-cert-validity-days:
    description:
      "The number of days the CA certificate is valid for. Defaults to 1."
    required: false
    default: "1"
  cert-validity-days:
    description:
      "The number of days the server certificate is valid for. Defaults to 1."
    required: false
    default: "1"

  # AWS role inputs
  aws-role-duration-seconds:
    description:
      "The duration in seconds for the assumed role. Defaults to 900 (15
      minutes)."
    required: false
    default: "900"
  aws-region:
    description:
      "The AWS region for resources unless specified in other inputs."
    required: false
  aws-role-arn:
    description:
      "The AWS role that grants the necessary permissions, including ECR pull
      access for private repositories, and, if for Kubernetes, EKS describe
      permissions."
    required: false

  # Kubernetes inputs
  use-k8s:
    description:
      "Whether to setup GAP for communicating with K8s. Cannot be used with
      use-argocd. Defaults to false."
    required: false
    default: "false"
  k8s-cluster-name:
    description: "The EKS cluster name to target. Required if use-k8s is true."
    required: false
  k8s-cluster-aws-region:
    description:
      "The region for the EKS cluster, if different from aws-region input."
    required: false
  k8s-api-endpoint-port:
    description: "The port number for accessing the Kubernetes API server."
    required: false
    default: "443"

  # Local proxy inputs
  enable-proxy-debug:
    description:
      "Enable or disable detailed Envoy proxy logs used for K8s API access. When
      enabled, debug logs are generated locally, and container logs are streamed
      to the console for troubleshooting."
    required: false
    default: "false"
  github-oidc-token-header-name:
    description:
      "Specifies the name of the HTTP header used to pass the GitHub OIDC JWT
      token. This header is automatically injected by the local proxy and must
      not be the same as the default 'Authorization' header."
    required: false
    default: "x-authorization-github-jwt"
  envoy-proxy-image:
    description: "Envoy Proxy image used to run Envoy proxy for GAP."
    required: false
    default: "envoyproxy/envoy:v1.33.0"
  proxy-port:
    description: "The port the proxy will listen on. Defaults to 8080."
    required: false
    default: "8080"
  proxy-log-level:
    description:
      "The log level for the Envoy proxy. Controls the verbosity of logs
      generated by Envoy. Common values include 'debug', 'info', 'warning',
      'error', and 'critical'. Defaults to 'info'."
    required: false
    default: "info"
  dynamic-proxy-port:
    description: "The port the dynamic proxy will listen on. Defaults to 443."
    required: false
    default: "443"
  main-dns-zone:
    description:
      "The DNS zone is used for exposing services. It is required when using the
      dynamic local proxy to prevent sending requests and exposing sensitive
      information to random external endpoints. This ensures that the dynamic
      local proxy is used only for the specific DNS zone."
    required: true
  websockets-proxy-port:
    description:
      "Port number used by the listener for the local proxy of WebSocket
      services."
    default: "9443"
    required: false
  websockets-services:
    description:
      "List of service names to be configured in the local proxy for proper
      handling of all required headers, including the JWT token. It should be a
      comma-separated list, for example: 'gap-ws-echo,gap-ws-hello'. Note: If
      you are using Crib, append the Devspace namespace name as the suffix in
      the service name, e.g., 'gap-geth-${namespace-name},
      gap-custom-ws-${namespace-name}'."
    default: ""
    required: false

outputs:
  local-proxy-port:
    description: "The port the local proxy will listen on."
    value: ${{ inputs.proxy-port }}
  dynamic-proxy-port:
    description: "The port the dynamic proxy will listen on."
    value: ${{ inputs.dynamic-proxy-port }}
  websockets-proxy-port:
    description: "The port the WebSocket proxy will listen on."
    value: ${{ inputs.websockets-proxy-port }}

runs:
  using: composite
  steps:
    - name: Validate inputs
      shell: bash
      env:
        DYNAMIC_PROXY_PORT: ${{ inputs.dynamic-proxy-port }}
        MAIN_DNS_ZONE: ${{ inputs.main-dns-zone }}
        PROXY_PORT: ${{ inputs.proxy-port }}
        WEBSOCKETS_PROXY_PORT: ${{ inputs.websockets-proxy-port }}
      run: |
        if [[ -z "${MAIN_DNS_ZONE:-}" ]]; then
          echo "::error::inputs.main-dns-zone is required."
          exit 1
        fi

        if [[ "${DYNAMIC_PROXY_PORT}" == "${PROXY_PORT}" || \
              "${DYNAMIC_PROXY_PORT}" == "${WEBSOCKETS_PROXY_PORT}" || \
              "${PROXY_PORT}" == "${WEBSOCKETS_PROXY_PORT}" ]]; then
          echo "::error::PROXY_PORT, DYNAMIC_PROXY_PORT, and WEBSOCKETS_PROXY_PORT must have unique values."
          exit 1
        fi

    - name: Assume role
      # We only need to assume a role if we intend to use k8s API server access via the proxy
      if: inputs.use-k8s == 'true'
      uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
      with:
        role-to-assume: ${{ inputs.aws-role-arn }}
        role-duration-seconds: ${{ inputs.aws-role-duration-seconds }}
        aws-region: ${{ inputs.aws-region }}
        mask-aws-account-id: true

    - name: Setup Certificate Authority
      # Generate a local ephemeral CA key and cert to sign the local proxy's certificate.
      # ---
      # Kubectl requires a TLS connection to it's configured endpoint, and performs certificate
      # validation through the CA configured in the kubeconfig.
      # The local envoy container will act as the k8s endpoint for kubectl, and therefore requires a
      # certificate signed by a trusted CA. Because this is for local TLS we can generate a CA, generate a server
      # certificate, sign the server certificate with the CA, and update the CA in the kubeconfig to trust it.
      # Also useful for other use-cases where a local TLS connection is required.
      shell: bash
      env:
        GAP_NAME: ${{ inputs.gap-name }}
        PATH_CERTS_DIR_PREFIX: /tmp/setup-gap
        CA_CERT_VALIDITY_DAYS: ${{ inputs.ca-cert-validity-days}}
      run: |
        PATH_CERTS_DIR="${PATH_CERTS_DIR_PREFIX}-${GAP_NAME}"
        echo "PATH_CERTS_DIR=${PATH_CERTS_DIR}" | tee -a $GITHUB_ENV
        mkdir -p "${PATH_CERTS_DIR}"

        echo "::debug::Generating new CA key+cert. Writing them to ${PATH_CERTS_DIR}/ca.key and ${PATH_CERTS_DIR}/ca.crt"
        openssl ecparam -genkey -name prime256v1 -out "${PATH_CERTS_DIR}/ca.key"
        openssl req -x509 -new \
          -nodes -key "${PATH_CERTS_DIR}/ca.key" \
          -sha256 \
          -days "${CA_CERT_VALIDITY_DAYS}" \
          -out "${PATH_CERTS_DIR}/ca.crt" \
          -subj "/CN=My CA"

        echo "::debug::Adding new CA to system trust store"
        sudo mkdir -p /usr/local/share/ca-certificates/extra
        sudo cp "${PATH_CERTS_DIR}/ca.crt" "/usr/local/share/ca-certificates/extra/setup-gap-${GAP_NAME}.crt"
        sudo update-ca-certificates

    - name: Generate and Sign Proxy TLS listener certificate
      shell: bash
      env:
        CERT_VALIDITY_DAYS: ${{ inputs.cert-validity-days}}
        MAIN_DNS_ZONE: ${{ inputs.main-dns-zone }}
      run: |
        echo "::debug::Generating server key and certificate signing request (CSR)"
        openssl ecparam -genkey -name prime256v1 -out "${PATH_CERTS_DIR}/server.key"
        openssl req -new \
          -key "${PATH_CERTS_DIR}/server.key" \
          -out "${PATH_CERTS_DIR}/server.csr" \
          -subj "/CN=localhost" \
          -addext "subjectAltName=DNS:localhost,IP:127.0.0.1"

        echo "::debug::Generating SAN extension file"
        echo -e "subjectAltName=DNS:localhost,IP:127.0.0.1,DNS:*.${MAIN_DNS_ZONE}" > "${PATH_CERTS_DIR}/san.ext"

        echo "::debug::Signing server certificate with CA"
        openssl x509 -req -in "${PATH_CERTS_DIR}/server.csr" \
          -CA "${PATH_CERTS_DIR}/ca.crt" \
          -CAkey "${PATH_CERTS_DIR}/ca.key" \
          -CAcreateserial \
          -out "${PATH_CERTS_DIR}/server.crt" \
          -days "${CERT_VALIDITY_DAYS}" \
          -sha256 \
          -extfile "${PATH_CERTS_DIR}/san.ext"

        echo "::debug::Removing CSR and SAN extension files"
        rm "${PATH_CERTS_DIR}/server.csr" "${PATH_CERTS_DIR}/san.ext"

    - name: Setup Kubeconfig (K8s only)
      if: inputs.use-k8s == 'true'
      shell: bash
      run: |
        echo "::debug::Getting kubeconfig"
        aws eks update-kubeconfig --name ${{ inputs.k8s-cluster-name }} --region ${{ inputs.k8s-cluster-aws-region || inputs.aws-region }}

        # Get cluster arn for modifying kubeconfig
        CLUSTER_ARN=$(aws eks describe-cluster --name ${{ inputs.k8s-cluster-name }} --region ${{ inputs.k8s-cluster-aws-region || inputs.aws-region }} --query "cluster.arn" --output text)
        echo "::add-mask::${CLUSTER_ARN}"

        echo "::debug::Setting up kubeconfig for localhost proxy"

        kubectl config set clusters."$CLUSTER_ARN".server "https://localhost:${{ inputs.proxy-port }}"

        # Set the certificate-authority to the ephemeral certificate authority configured above
        kubectl config set clusters.$CLUSTER_ARN.certificate-authority "${PATH_CERTS_DIR}/ca.crt"

        # Remove certificate-authority-data populated from `aws eks update-kubeconfig` which is for the endpoint which is not publicly accessible
        kubectl config unset clusters.$CLUSTER_ARN.certificate-authority-data

    - name: Install gomplate and verify installation
      shell: bash
      run: |
        curl -L https://github.com/hairyhenderson/gomplate/releases/latest/download/gomplate_linux-amd64 -o /usr/local/bin/gomplate
        chmod +x /usr/local/bin/gomplate
        gomplate --version

    - name: Run local Envoy proxy
      shell: sh
      env:
        DYNAMIC_PROXY_PORT: ${{ inputs.dynamic-proxy-port }}
        ENABLE_PROXY_DEBUG: ${{ inputs.enable-proxy-debug }}
        GITHUB_OIDC_TOKEN_HEADER_NAME:
          ${{ inputs.github-oidc-token-header-name }}
        PROXY_LOG_LEVEL: ${{ inputs.proxy-log-level }}
        ENVOY_PROXY_IMAGE: ${{ inputs.envoy-proxy-image }}
        K8S_API_ENDPOINT_PORT: ${{ inputs.k8s-api-endpoint-port }}
        MAIN_DNS_ZONE: ${{ inputs.main-dns-zone }}
        PROXY_PORT: ${{ inputs.proxy-port }}
        WEBSOCKETS_PROXY_PORT: ${{ inputs.websockets-proxy-port }}
        WEBSOCKETS_SERVICES: ${{ inputs.websockets-services }}
      run: |
        # Get the Github OIDC hostname
        export GITHUB_OIDC_HOSTNAME=$(echo $ACTIONS_ID_TOKEN_REQUEST_URL | awk -F[/:] '{print $4}')

        # List of required ENVs to check
        required_env_vars="DYNAMIC_PROXY_PORT ENABLE_PROXY_DEBUG GITHUB_OIDC_TOKEN_HEADER_NAME ENVOY_PROXY_IMAGE GITHUB_OIDC_HOSTNAME K8S_API_ENDPOINT_PORT MAIN_DNS_ZONE PROXY_LOG_LEVEL PROXY_PORT GITHUB_REPOSITORY WEBSOCKETS_PROXY_PORT"

        # Loop through each variable and check if it's empty
        for var in $required_env_vars; do
          eval value=\$$var
          if [ -z "$value" ]; then
            echo "::error::Required environment variable '$var' is not set."
            exit 1
          fi
        done

        # Generate Envoy config from template
        gomplate -f "${GITHUB_ACTION_PATH}/envoy.yaml.gotmpl" -o "${GITHUB_ACTION_PATH}/envoy.yaml"

        # Generate LUA script from template
        gomplate -f "${GITHUB_ACTION_PATH}/github_oidc.lua.gotmpl" -o "${GITHUB_ACTION_PATH}/github_oidc.lua"

        # Copy AWS CA certs
        cp ${{ github.action_path }}/aws-ca.crt "${PATH_CERTS_DIR}"
        chmod 644 "${PATH_CERTS_DIR}/server.key"

        # If debug is enabled, adjust log level and print config
        if [ "$ENABLE_PROXY_DEBUG" = "true" ]; then
          export PROXY_LOG_LEVEL="debug"
          echo "Envoy log level set to DEBUG. Configuration:"
          cat "${GITHUB_ACTION_PATH}/envoy.yaml"
        fi

        echo "Validating Envoy config..."
        if ! docker run --rm \
            --name "gap" \
            -p "${DYNAMIC_PROXY_PORT}:${DYNAMIC_PROXY_PORT}" \
            -p "${PROXY_PORT}:${PROXY_PORT}" \
            -p "${WEBSOCKETS_PROXY_PORT}:${WEBSOCKETS_PROXY_PORT}" \
            -v "${PATH_CERTS_DIR}":/tls \
            -v "${GITHUB_ACTION_PATH}/envoy.yaml":/etc/envoy/envoy.yaml \
            -v "${GITHUB_ACTION_PATH}/json.lua":/etc/envoy/json.lua \
            -v "${GITHUB_ACTION_PATH}/github_oidc.lua":/etc/envoy/github_oidc.lua \
            "${ENVOY_PROXY_IMAGE}" \
            /usr/local/bin/envoy --mode validate -c /etc/envoy/envoy.yaml \
            --log-level "${PROXY_LOG_LEVEL}"; then
          echo "::error::Envoy configuration validation failed."
          exit 1
        fi

        echo "Starting the local Envoy proxy..."
        docker run --rm -d \
          --name "gap" \
          -p "${DYNAMIC_PROXY_PORT}:${DYNAMIC_PROXY_PORT}" \
          -p "${PROXY_PORT}:${PROXY_PORT}" \
          -p "${WEBSOCKETS_PROXY_PORT}:${WEBSOCKETS_PROXY_PORT}" \
          -v "${PATH_CERTS_DIR}":/tls \
          -v "${GITHUB_ACTION_PATH}/envoy.yaml":/etc/envoy/envoy.yaml \
          -v "${GITHUB_ACTION_PATH}/json.lua":/etc/envoy/json.lua \
          -v "${GITHUB_ACTION_PATH}/github_oidc.lua":/etc/envoy/github_oidc.lua \
          "${ENVOY_PROXY_IMAGE}" \
          /usr/local/bin/envoy -c /etc/envoy/envoy.yaml \
          --log-level "${PROXY_LOG_LEVEL}"

    - name: Verify Envoy Proxy
      shell: bash
      env:
        USE_K8S: ${{ inputs.use-k8s }}
        PROXY_PORT: ${{ inputs.proxy-port }}
        DYNAMIC_PROXY_PORT: ${{ inputs.dynamic-proxy-port }}
        WEBSOCKETS_PROXY_PORT: ${{ inputs.websockets-proxy-port }}
      run: |
        check_proxy() {
          local port=$1
          local name=$2

          echo "Checking if the ${name} proxy is up and running on [https://localhost:${port}] ..."
          for attempt in {1..10}; do
            if curl --silent --cacert "${PATH_CERTS_DIR}/ca.crt" --head https://localhost:${port} > /dev/null 2>&1; then
              echo "${name} proxy is up, and the HTTPS connection is successful."
              return 0
            else
              echo "Waiting for the ${name} proxy to start... Attempt ${attempt}/10"
              sleep 3
            fi
          done

          echo "Timed out waiting for the ${name} proxy to start."
          return 1
        }

        if [ "${USE_K8S}" == "true" ]; then
          check_proxy "${PROXY_PORT}" "K8s API" || exit 1
        fi

        check_proxy "${DYNAMIC_PROXY_PORT}" "Dynamic local proxy listener" || exit 1
        check_proxy "${WEBSOCKETS_PROXY_PORT}" "Websockets local proxy listener" || exit 1

    - name: Collect Envoy proxy logs when debug is enabled
      uses: jwalton/gh-docker-logs@2741064ab9d7af54b0b1ffb6076cf64c16f0220e # v2.2.2
      if: inputs.enable-proxy-debug == 'true' || failure()
