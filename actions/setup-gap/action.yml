name: setup-gap
description: "setup github actions proxy"

inputs:
  # general inputs
  gap-name:
    description:
      "The name of the GAP. Used in the dir name for self-signed certs and the
      docker container name. Required if using multiple invocations of this in
      the same job."
    required: false
    default: "default"
  ca-cert-validity-days:
    description:
      "The number of days the CA certificate is valid for. Defaults to 1."
    required: false
    default: "1"
  cert-validity-days:
    description:
      "The number of days the server certificate is valid for. Defaults to 1."
    required: false
    default: "1"
  # aws role inputs
  aws-role-duration-seconds:
    description:
      "The duration in seconds for the assumed role. Defaults to 900 (15
      minutes)."
    required: false
    default: "900"
  aws-region:
    description: "The AWS region resources unless specified in other inputs"
    required: false
  aws-role-arn:
    description:
      "The AWS role that grants the necessary permissions, including ECR pull
      access for private repositories, and, if for Kubernetes, EKS describe
      permissions."
    required: false
  # k8s inputs
  use-k8s:
    description:
      "Whether to setup GAP for communicating with K8s. Cannot be used with
      use-argocd. Defaults to false."
    required: false
    default: "false"
  k8s-cluster-name:
    description: "The EKS cluster name to target. Required if use-k8s is true."
    required: false
  k8s-cluster-aws-region:
    description:
      "The region for the EKS cluster, if different from aws-region input."
    required: false
  k8s-api-endpoint-port:
    required: false
    default: "443"
    description: "The port number for accessing the Kubernetes API server."
  # local proxy inputs
  enable-proxy-debug:
    required: false
    default: "false"
    description:
      "Enable or disable detailed Envoy proxy logs used for K8s API access. When
      enabled, debug logs are generated locally, and container logs are streamed
      to the console for troubleshooting."
  github-oidc-token-header-name:
    required: false
    default: "x-authorization-github-jwt"
    description:
      "Specifies the name of the HTTP header used to pass the GitHub OIDC JWT
      token. This header is automatically injected by the local proxy and must
      not be the same as the default 'Authorization' header."
  envoy-proxy-image:
    description: "Envoy Proxy image used to run Envoy proxy for GAP"
    required: false
    default: "envoyproxy/envoy:v1.33.0"
  proxy-port:
    description: "The port the proxy will listen on. Defaults to 8080."
    required: false
    default: "8080"
  proxy-log-level:
    description:
      "The log level for the Envoy proxy. Controls the verbosity of logs
      generated by Envoy. Common values include 'debug', 'info', 'warning',
      'error', and 'critical'. Defaults to 'info'."
    required: false
    default: "info"
  proxy-additional-sans:
    description:
      "Add extra SANS to the self-signed certs provided by the proxy.
      This makes it possible to use e.g. /etc/hosts file to route traffic
      to the proxy while maintaining the original host header in clients
      that don't support overriding it."
    required: false
    default: ""
  dynamic-proxy-port:
    description: "The port the dynamic proxy will listen on. Defaults to 9090."
    required: false
    default: "9090"
  main-dns-zone:
    description:
      "The DNS zone is used for exposing services. It is required when using the
      dynamic local proxy to prevent sending requests and exposing sensitive
      information to random external endpoints. This ensures that the dynamic
      local proxy is used only for the specific DNS zone."
    required: true
outputs:
  local-proxy-port:
    description: "The port the local proxy will listen on."
    value: ${{ inputs.proxy-port }}

runs:
  using: composite
  steps:
    - name: Assume role
      # We only need to assume a role if we intend to use k8s API server access via the proxy
      if: inputs.use-k8s == 'true'
      uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
      with:
        role-to-assume: ${{ inputs.aws-role-arn }}
        role-duration-seconds: ${{ inputs.aws-role-duration-seconds }}
        aws-region: ${{ inputs.aws-region }}
        mask-aws-account-id: true

    - name: Setup Certificate Authority
      # Generate a local ephemeral CA key and cert to sign the local proxy's certificate.
      # ---
      # Kubectl requires a TLS connection to it's configured endpoint, and performs certificate
      # validation through the CA configured in the kubeconfig.
      # The local envoy container will act as the k8s endpoint for kubectl, and therefore requires a
      # certificate signed by a trusted CA. Because this is for local TLS we can generate a CA, generate a server
      # certificate, sign the server certificate with the CA, and update the CA in the kubeconfig to trust it.
      # Also useful for other use-cases where a local TLS connection is required.
      shell: bash
      env:
        GAP_NAME: ${{ inputs.gap-name }}
        PATH_CERTS_DIR_PREFIX: /tmp/setup-gap
        CA_CERT_VALIDITY_DAYS: ${{ inputs.ca-cert-validity-days}}
      run: |
        PATH_CERTS_DIR="${PATH_CERTS_DIR_PREFIX}-${GAP_NAME}"
        echo "PATH_CERTS_DIR=${PATH_CERTS_DIR}" | tee -a $GITHUB_ENV
        mkdir -p "${PATH_CERTS_DIR}"

        echo "::debug::Generating new CA key+cert. Writing them to ${PATH_CERTS_DIR}/ca.key and ${PATH_CERTS_DIR}/ca.crt"
        openssl ecparam -genkey -name prime256v1 -out "${PATH_CERTS_DIR}/ca.key"
        openssl req -x509 -new \
          -nodes -key "${PATH_CERTS_DIR}/ca.key" \
          -sha256 \
          -days "${CA_CERT_VALIDITY_DAYS}" \
          -out "${PATH_CERTS_DIR}/ca.crt" \
          -subj "/CN=My CA"

        echo "::debug::Adding new CA to system trust store"
        sudo mkdir -p /usr/local/share/ca-certificates/extra
        sudo cp "${PATH_CERTS_DIR}/ca.crt" "/usr/local/share/ca-certificates/extra/setup-gap-${GAP_NAME}.crt"
        sudo update-ca-certificates

    - name: Generate and Sign Proxy TLS listener certificate
      shell: bash
      env:
        CERT_VALIDITY_DAYS: ${{ inputs.cert-validity-days}}
        PROXY_ADDITIONAL_SANS: ${{ inputs.proxy-additional-sans }}
      run: |
        echo "::debug::Generating server key and certificate signing request (CSR)"
        openssl ecparam -genkey -name prime256v1 -out "${PATH_CERTS_DIR}/server.key"
        openssl req -new \
          -key "${PATH_CERTS_DIR}/server.key" \
          -out "${PATH_CERTS_DIR}/server.csr" \
          -subj "/CN=localhost" \
          -addext "subjectAltName=DNS:localhost,IP:127.0.0.1"

        echo "::debug::Generating SAN extension file"
        echo -e "subjectAltName=DNS:localhost,IP:127.0.0.1" > "${PATH_CERTS_DIR}/san.ext"

        if [ -n "${PROXY_ADDITIONAL_SANS}" ]; then
            # Split the ADDITIONAL_SANS into an array
            IFS=',' read -ra SAN_LIST <<< "${PROXY_ADDITIONAL_SANS}"
            
            # Loop through each SAN and append it to the existing subjectAltName line
            for SAN in "${SAN_LIST[@]}"; do
                sed -i "s/$/,DNS:${SAN}/" "${PATH_CERTS_DIR}/san.ext"
            done
        fi

        echo "::debug::Signing server certificate with CA"
        openssl x509 -req -in "${PATH_CERTS_DIR}/server.csr" \
          -CA "${PATH_CERTS_DIR}/ca.crt" \
          -CAkey "${PATH_CERTS_DIR}/ca.key" \
          -CAcreateserial \
          -out "${PATH_CERTS_DIR}/server.crt" \
          -days "${CERT_VALIDITY_DAYS}" \
          -sha256 \
          -extfile "${PATH_CERTS_DIR}/san.ext"

        echo "::debug::Removing CSR and SAN extension files"
        rm "${PATH_CERTS_DIR}/server.csr" "${PATH_CERTS_DIR}/san.ext"

    - name: Setup Kubeconfig (K8s only)
      if: inputs.use-k8s == 'true'
      shell: bash
      run: |
        echo "::debug::Getting kubeconfig"
        aws eks update-kubeconfig --name ${{ inputs.k8s-cluster-name }} --region ${{ inputs.k8s-cluster-aws-region || inputs.aws-region }}

        # Get cluster arn for modifying kubeconfig
        CLUSTER_ARN=$(aws eks describe-cluster --name ${{ inputs.k8s-cluster-name }} --region ${{ inputs.k8s-cluster-aws-region || inputs.aws-region }} --query "cluster.arn" --output text)
        echo "::add-mask::${CLUSTER_ARN}"

        echo "::debug::Setting up kubeconfig for localhost proxy"

        kubectl config set clusters."$CLUSTER_ARN".server "https://localhost:${{ inputs.proxy-port }}"

        # Set the certificate-authority to the ephemeral certificate authority configured above
        kubectl config set clusters.$CLUSTER_ARN.certificate-authority "${PATH_CERTS_DIR}/ca.crt"

        # Remove certificate-authority-data populated from `aws eks update-kubeconfig` which is for the endpoint which is not publicly accessible
        kubectl config unset clusters.$CLUSTER_ARN.certificate-authority-data

    - name: Run Envoy proxy
      shell: sh
      env:
        DYNAMIC_PROXY_PORT: ${{ inputs.dynamic-proxy-port }}
        ENABLE_PROXY_DEBUG: ${{ inputs.enable-proxy-debug }}
        GITHUB_OIDC_TOKEN_HEADER_NAME:
          ${{ inputs.github-oidc-token-header-name }}
        PROXY_LOG_LEVEL: ${{ inputs.proxy-log-level }}
        ENVOY_PROXY_IMAGE: ${{ inputs.envoy-proxy-image }}
        K8S_API_ENDPOINT_PORT: ${{ inputs.k8s-api-endpoint-port }}
        MAIN_DNS_ZONE: ${{ inputs.main-dns-zone }}
        PROXY_PORT: ${{ inputs.proxy-port }}
      run: |
        # Get the Github OIDC hostname
        export GITHUB_OIDC_HOSTNAME=$(echo $ACTIONS_ID_TOKEN_REQUEST_URL | awk -F[/:] '{print $4}')

        # List of required ENVs to check
        required_env_vars="DYNAMIC_PROXY_PORT ENABLE_PROXY_DEBUG GITHUB_OIDC_TOKEN_HEADER_NAME ENVOY_PROXY_IMAGE GITHUB_OIDC_HOSTNAME K8S_API_ENDPOINT_PORT MAIN_DNS_ZONE PROXY_LOG_LEVEL PROXY_PORT GITHUB_REPOSITORY"

        # Loop through each variable and check if it's empty
        for var in $required_env_vars; do
          # Use eval to get the value of the environment variable
          eval value=\$$var
          if [ -z "$value" ]; then
            echo "Error: $var is not set."
            exit 1
          fi
        done

        # Generate Envoy config from template
        ls -l
        envsubst < "${GITHUB_ACTION_PATH}/envoy.yaml.template" > "${GITHUB_ACTION_PATH}/envoy.yaml"

        # Copy AWS CA certs
        cp ${{ github.action_path }}/aws-ca.crt "${PATH_CERTS_DIR}"
        chmod 644 "${PATH_CERTS_DIR}/server.key"

        # If debug is enabled, adjust log level and print config
        if [ "$ENABLE_PROXY_DEBUG" = "true" ]; then
          export PROXY_LOG_LEVEL="debug"
          echo "Envoy log level set to DEBUG. Configuration:"
          cat "${GITHUB_ACTION_PATH}/envoy.yaml"
        fi

        docker run --rm -d \
          --name "gap-v2" \
          -p "${DYNAMIC_PROXY_PORT}:${DYNAMIC_PROXY_PORT}" \
          -p "${PROXY_PORT}:${PROXY_PORT}" \
          -v "${PATH_CERTS_DIR}":/tls \
          -v "${GITHUB_ACTION_PATH}/envoy.yaml":/etc/envoy/envoy.yaml \
          -v "${GITHUB_ACTION_PATH}/json.lua":/etc/envoy/json.lua \
          "${ENVOY_PROXY_IMAGE}" \
          /usr/local/bin/envoy -c /etc/envoy/envoy.yaml \
          --log-level "${PROXY_LOG_LEVEL}"

    - name: Verify Envoy Proxy
      shell: bash
      env:
        USE_K8S: ${{ inputs.use-k8s }}
        PROXY_PORT: ${{ inputs.proxy-port }}
        DYNAMIC_PROXY_PORT: ${{ inputs.dynamic-proxy-port }}
      run: |
        check_proxy() {
          local port=$1
          local name=$2

          echo "Checking if the ${name} proxy is up and running on https://localhost:${port}..."
          for attempt in {1..10}; do
            if curl --silent --cacert "${PATH_CERTS_DIR}/ca.crt" --head https://localhost:${port} > /dev/null 2>&1; then
              echo "${name} proxy is up, and the HTTPS connection is successful."
              return 0
            else
              echo "Waiting for the ${name} proxy to start... Attempt ${attempt}/10"
              sleep 3
            fi
          done

          echo "Timed out waiting for the ${name} proxy to start."
          return 1
        }

        if [ "${USE_K8S}" == "true" ]; then
          check_proxy "${PROXY_PORT}" "K8s API" || exit 1
        fi

        check_proxy "${DYNAMIC_PROXY_PORT}" "Dynamic local proxy" || exit 1

    - name: Collect Envoy proxy logs when debug is enabled
      uses: jwalton/gh-docker-logs@2741064ab9d7af54b0b1ffb6076cf64c16f0220e # v2.2.2
      if:
        inputs.use-k8s == 'true' && (inputs.enable-proxy-debug == 'true' ||
        failure())
