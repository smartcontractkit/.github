name: setup-gap
description: "setup github actions proxy"

inputs:
  # general inputs
  checkout-repo:
    description: "enable git checkout repo"
    required: false
    default: "true"
  checkout-repo-fetch-depth:
    description: "number of commits to fetch"
    required: false
    default: "0"
  # aws sig4 proxy inputs
  api-gateway-host:
    description: "aws api gateway host"
    required: true
  proxy-version:
    description: "sig proxy version if using the public ecr"
    required: false
    default: "1.7"
  proxy-port:
    description: "sig proxy port"
    required: false
    default: "8080"
  # ecr inputs
  use-private-ecr-registry:
    description: "Whether to use a private ECR registry for the aws-sigv4-proxy image"
    required: false
    default: "false"
  ecr-private-registry:
    description: "The ECR registry (account id) for the aws-sigv4-proxy. Required if use-private-ecr-registry is true."
    required: false
  ecr-private-image-tag:
    description: "aws-sigv4-proxy image tag for the private ECR registry"
    required: false
    default: "6cc1e6d2bce23c04aace47d26511ad65205975b8"
  # aws role inputs
  aws-role-duration-seconds:
    description: ""
    required: false
    default: "900"
  aws-region:
    description: "The region for the AWS EKS and ECR resources"
    required: false
  aws-role-arn:
    description: "The AWS role with API Gateway invoke permissions, ECR pull permissions for aws-sigv4-proxy, and if for k8s then EKS describe permissions"
    required: false
  # argocd inputs
  use-argocd:
    description: "Whether to setup GAP for communicating with argocd"
    required: false
    default: "false"
  argocd-version:
    description: ""
    required: false
    default: "2.8.2"
  argocd-user:
    description: "The username for argocd login"
    required: false
  argocd-pass:
    description: "The password for argocd login"
    required: false
  # k8s inputs
  use-k8s:
    description: "Whether to setup GAP for communicating with k8s"
    required: false
    default: "false"
  k8s-cluster-name:
    description: "The EKS cluster name to generate a kubeconfig for"
    required: false
  # tls inputs
  tls-ca-private-key:
    description: "The private key for the tls certificate"
    required: false
  tls-ca-cert:
    description: "The ca certificate for the tls certificate"
    required: false
  # grafana cloud inputs
  metrics-job-name:
    description: "grafana metrics job name"
    required: false
    default: setup-gap
  gc-host:
    description: "grafana cloud hostname"
    required: false
  gc-basic-auth:
    description: "grafana cloud basic auth"
    required: false

runs:
  using: composite
  steps:
    - name: Checkout repo
      if: inputs.checkout-repo == 'true'
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
      with:
        fetch-depth: ${{ inputs.checkout-repo-fetch-depth }}

    - name: Assume role
      uses: aws-actions/configure-aws-credentials@010d0da01d0b5a38af31e9c3470dbfdabdecca3a # v4.0.1
      with:
        role-to-assume: ${{ inputs.aws-role-arn }}
        role-duration-seconds: ${{ inputs.aws-role-duration-seconds }}
        aws-region: ${{ inputs.aws-region }}

    - name: Setup Certificate Authority (K8s only)
      if: inputs.use-k8s == 'true'
      run: |
        mkdir -p /tmp/tls/ca

        if [ -n "${{ inputs.tls-ca-private-key }}" ] && [ -n "${{ inputs.tls-ca-cert }}" ]; then
          # Use provided CA key+cert
          echo "${{ inputs.tls-ca-private-key }}" > /tmp/tls/ca/ca.key
          echo "${{ inputs.tls-ca-cert }}" > /tmp/tls/ca/ca.crt
        else
          # Generate CA key+cert
          openssl genrsa -out /tmp/tls/ca/ca.key 4096
          openssl req -x509 -new -nodes -key /tmp/tls/ca/ca.key -sha256 -days 1 -out /tmp/tls/ca/ca.crt -subj "/CN=My CA"
        fi

    - name: Generate and Sign Server Certificate (K8s only)
      if: inputs.use-k8s == 'true'
      run: |
        mkdir -p /tmp/tls/server

        # Generate server key and certificate signing request (CSR)
        openssl genrsa -out /tmp/tls/server/server.key 2048
        openssl req -new -key /tmp/tls/server/server.key -out /tmp/tls/server/server.csr -subj "/CN=localhost" -addext "subjectAltName=DNS:localhost,IP:127.0.0.1"

        # Generate SAN extension file
        echo -e "subjectAltName=DNS:localhost,IP:127.0.0.1" > /tmp/tls/server/san.ext

        # Sign the CSR
        openssl x509 -req -in /tmp/tls/server/server.csr -CA /tmp/tls/ca/ca.crt -CAkey /tmp/tls/ca/ca.key -CAcreateserial -out /tmp/tls/server/server.crt -days 1 -sha256 -extfile /tmp/tls/server/san.ext

        # Delete intermediate files
        rm /tmp/tls/server/server.csr /tmp/tls/server/san.ext

    - name: Setup Kubeconfig (K8s only)
      if: inputs.use-k8s == 'true'
      run: |
        # Generate kubeconfig through aws cli
        aws eks update-kubeconfig --name ${{ inputs.k8s-cluster-name }} --region ${{ inputs.aws-region }}

        # Get cluster arn for modifying kubeconfig
        # TODO - may be able to use `kk config get-contexts --no-headers --output=name` instead (if there's only one context in the kubeconfig file)
        CLUSTER_ARN=$(aws eks describe-cluster --name ${{ inputs.k8s-cluster-name }} --region ${{ inputs.aws-region }} --query "cluster.arn" --output text)
        echo "::add-mask::${CLUSTER_ARN}"

        # Set the certificate-authority to the certificate authority configured above
        kubectl config set clusters.$CLUSTER_ARN.certificate-authority /tmp/tls/ca/ca.crt

        # Remove certificate-authority-data populated from `aws eks update-kubeconfig`
        kubectl config unset clusters.$CLUSTER_ARN.certificate-authority-data

        # Update the server to use the proxy
        kubectl config set clusters.$CLUSTER_ARN.server https://localhost:${{ inputs.proxy-port }}/primary

    - name: Login to AWS ECR (public ecr only)
      if: inputs.use-private-ecr-registry != 'true'
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2.0.1
      env:
        AWS_REGION: us-west-2
      with:
        registry-type: public

    - name: Run aws sig4 proxy container (public ecr only)
      shell: bash
      env:
        AWS_ACCESS_KEY_ID: ${{ env.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ env.AWS_SECRET_ACCESS_KEY }}
        AWS_SESSION_TOKEN: ${{ env.AWS_SESSION_TOKEN }}
      run: |
        docker run --rm -d \
          -e AWS_ACCESS_KEY_ID \
          -e AWS_SECRET_ACCESS_KEY \
          -e AWS_SESSION_TOKEN \
          -p "${{ inputs.proxy-port }}":"${{ inputs.proxy-port }}" \
          public.ecr.aws/aws-observability/aws-sigv4-proxy:${{ inputs.proxy-version }} \
          --name execute-api --region ${{ inputs.aws-region }} \
          --host "${{ inputs.api-gateway-host }}" \
          --log-failed-requests

    - name: Login to AWS ECR (private ecr only)
      if: inputs.use-private-ecr-registry == 'true'
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2.0.1
      env:
        AWS_REGION: ${{ inputs.aws-region }}
      with:
        registry: ${{ inputs.ecr-private-registry }}

    - name: Run aws sig4 proxy container (private ecr only)
      shell: bash
      env:
        AWS_ACCESS_KEY_ID: ${{ env.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ env.AWS_SECRET_ACCESS_KEY }}
        AWS_SESSION_TOKEN: ${{ env.AWS_SESSION_TOKEN }}
      run: |
        docker run --rm -d \
          -e AWS_ACCESS_KEY_ID \
          -e AWS_SECRET_ACCESS_KEY \
          -e AWS_SESSION_TOKEN \
          -p ${{ inputs.proxy-port }}:${{ inputs.proxy-port }} \
          -v /tmp/tls/server:/tls \
          ${{ inputs.private-ecr-registry }}.dkr.ecr.${{ inputs.aws-region }}/aws-sigv4-proxy:${{ inputs.private-ecr-image-tag }} -v \
            --name execute-api \
            --region ${{ inputs.aws-region }} \
            --host "${{ inputs.api-gateway-host }}" \
            --log-failed-requests --log-signing-process \
            --port :${{ inputs.proxy-port }} \
            --enable-tls --tls-key-file /tls/server.key --tls-cert-file /tls/server.crt \
            --duplicate-headers Authorization

    - name: Setup argocd
      if: inputs.use-argocd == 'true'
      uses: clowdhaus/argo-cd-action@6468ae064525e6a8adade0703b880b50912ab685 # v2.0.0
      with:
        command: version
        options: --client
        version: ${{ inputs.argocd-version }}

    - name: Argocd login
      if: inputs.use-argocd == 'true'
      shell: bash
      run:
        argocd login localhost:${{ inputs.proxy-port }}/primary --skip-test-tls
        --plaintext --grpc-web --username ${{ inputs.argocd-user }} --password
        ${{ inputs.argocd-pass }}

    - name: Collect metrics
      if: always()
      id: collect-gha-metrics
      uses: smartcontractkit/push-gha-metrics-action@d1618b772a97fd87e6505de97b872ee0b1f1729a # v2.0.2
      with:
        basic-auth: ${{ inputs.gc-basic-auth }}
        hostname: ${{ inputs.gc-host }}
        this-job-name: ${{ inputs.metrics-job-name }}
      continue-on-error: true
