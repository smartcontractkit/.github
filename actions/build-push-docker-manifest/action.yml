name: build-push-docker-manifest
description: |
  Reusable action to create docker manifest for multi-platform. Use this after
  the `build-push-docker` action to create and push the manifest.
inputs:
  cosign-oidc-identity-regexp:
    description: |
      > The identity expected in a valid Fulcio certificate.

      NOTE: Always prefix this with a `^` to match the start of the string
      and end with a `$` to match the end of the string for security.

      This is used to verify the cosigned image.

      Accepts the Go regular expression syntax described at:
      https://github.com/google/re2/wiki/Syntax.

      If this action is used in a reusable workflow, the identity will be the
      reusable workflow itself and not the calling workflow.

      Examples:
        - ^https://github.com/smartcontractkit/chainlink/.github/.github/workflows/.*$
        - ^https://github.com/smartcontractkit/.*$
    required: false
  cosign-oidc-issuer:
    description: "OIDC issuer for cosign"
    required: false
    default: "https://token.actions.githubusercontent.com"
  docker-manifest-sign:
    required: false
    description: "Sign the docker manifest"
    default: "true"
  docker-manifest-tag:
    required: true
    description: "Tag for the docker manifest"
  docker-registry-url:
    required: true
    description: |
      Hostname for the docker image registry.

      Example:
        public.ecr.aws
  docker-repository-name:
    required: true
    description: |
      Name of the Docker repository excluding hostname. Excludes any tags. Public ECR's will include a registry alias and a forward slash.

      Example:
        chainlink/chainlink # Public ECR
        chainlink/ccip # Public ECR
        my-repo-name # Private ECR
  docker-image-name-digests:
    required: true
    description: |
      Docker sha digests which will become added to this manifest. Comma separated list.

      Example:
       sha256:abc123,sha256:def456
  docker-image-availability-check:
    required: false
    description: |
      Enable checking if source images are available before creating manifest.
      If enabled, will retry checking image availability instead of just sleeping.
      If disabled, will use a fixed 30-second sleep.

      Note: Requires read permissions on the registry. Some IAM roles may only have write permissions.
    default: "true"
  github-workflow-repository:
    required: false
    description: |
      The repository for the GitHub Actions workflow. Format is `owner/repo`.

      This is used to verify the cosigned image.

      Set this if the action is used in a reusable workflow.

      Example:
        smartcontractkit/chainlink
    default: ${{ github.repository }}
  manifest-additional-tags:
    description: |
      Multi-line string of additional tags to apply to the Docker manifest.
      Each line should contain a single tag name.

      These tags will be created as aliases pointing to the same manifest as the primary tag.
      All tags are created atomically in a single operation and will have the same annotations.

      Useful for creating stable tags like "latest", "qa-latest", or environment-specific
      tags that should point to a specific build.

      Tags will be validated to ensure they follow Docker tag naming conventions.

      Example:
        manifest-additional-tags: |
          latest
          qa-latest
          stable
    required: false
  manifest-annotations:
    description: |
      Multi-line string of annotations to add to the Docker manifest.
      Each line should be in the format: key=value

      Uses OCI standard annotation keys. Common examples:
        org.opencontainers.image.source=https://github.com/owner/repo
        org.opencontainers.image.version=1.0.0
        org.opencontainers.image.revision=abc123
        org.opencontainers.image.title=my-app
        org.opencontainers.image.description=Description of the application
        org.opencontainers.image.licenses=MIT
        org.opencontainers.image.url=https://github.com/owner/repo
        org.opencontainers.image.ref.name=ubuntu

      NOTE: org.opencontainers.image.created will be automatically added with current timestamp.

      Example:
        manifest-annotations: |
          org.opencontainers.image.source=https://github.com/smartcontractkit/chainlink
          org.opencontainers.image.version=2.26.0
          org.opencontainers.image.revision=fd6445cf2b8177f7230a56e8f72f6d11e3caa03d
          org.opencontainers.image.title=chainlink
    required: false
  # aws inputs
  aws-region:
    description: "AWS region for ECR. For public images, use: us-east-1"
    required: false
    default: "us-east-1"
  aws-account-number:
    description: "AWS account number for the ECR registry."
    required: true
  aws-role-arn:
    description: "AWS role ARN with permissions to push ECR images."
    required: true

outputs:
  manifest-digest:
    description: "Docker @sha256:<sha> digest."
    value: ${{ steps.create-push-docker-manifest.outputs.manifest-digest }}
  manifest-tag:
    description: "Docker manifest tag."
    value: ${{ inputs.docker-manifest-tag }}
  manifest-name:
    description: "Docker manifest name."
    value: ${{ steps.create-push-docker-manifest.outputs.manifest-name }}
  manifest-name-with-digest:
    description: "Docker manifest name with digest."
    value:
      ${{ steps.create-push-docker-manifest.outputs.manifest-name-with-digest }}
  manifest-name-with-tag:
    description: "Docker manifest name with tag."
    value:
      ${{ steps.create-push-docker-manifest.outputs.manifest-name-with-tag }}

runs:
  using: composite
  steps:
    - name: Generate docker manifest name
      id: manifest-name
      shell: bash
      env:
        DOCKER_REGISTRY_URL: ${{ inputs.docker-registry-url }}
        DOCKER_REPOSITORY_NAME: ${{ inputs.docker-repository-name }}
      run: |
        echo "name=${DOCKER_REGISTRY_URL}/${DOCKER_REPOSITORY_NAME}" | tee -a "$GITHUB_OUTPUT"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
      with:
        version: v0.27.0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@7474bc4690e29a8392af63c5b98e7449536d5c3a # v4.3.1
      with:
        role-to-assume: ${{ inputs.aws-role-arn }}
        role-duration-seconds: 900
        aws-region: ${{ inputs.aws-region }}
        mask-aws-account-id: true

    - name: Login to ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2.0.1
      with:
        registry-type: >-
          ${{
            startsWith(inputs.docker-registry-url, 'public.ecr.aws') &&
          'public'
              || 'private'
          }}
        registries: ${{ inputs.aws-account-number }}

    - name: Generate manifest annotations
      id: generate-annotations
      shell: bash
      env:
        MANIFEST_ANNOTATIONS: ${{ inputs.manifest-annotations }}
      run: |
        # Build annotation flags for manifest
        ANNOTATION_FLAGS=()

        # Early exit if no annotations provided
        if [[ -z "${MANIFEST_ANNOTATIONS:-}" ]]; then
          echo "No manifest annotations provided, skipping annotation processing..."
        else
          echo "Generating manifest annotations..."
          while IFS= read -r line; do
            # Skip empty lines and lines starting with #
            if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*# ]]; then
              # Validate line format (key=value)
              if [[ "$line" =~ ^[^=]+=[^=]*$ ]]; then
                ANNOTATION_FLAGS+=("--annotation" "index:$line")
                echo "  Adding annotation: index:$line"
              else
                echo "  WARNING: Skipping invalid annotation format: $line"
              fi
            fi
          done <<< "$MANIFEST_ANNOTATIONS"
        fi

        # Convert array to space-separated string for output.
        ANNOTATION_FLAGS_STRING="${ANNOTATION_FLAGS[*]}"
        echo "annotation-flags=${ANNOTATION_FLAGS_STRING}" | tee -a "${GITHUB_OUTPUT}"

    - name: Process additional tags
      if: inputs.manifest-additional-tags != ''
      id: process-additional-tags
      shell: bash
      env:
        ADDITIONAL_TAGS: ${{ inputs.manifest-additional-tags }}
        DOCKER_MANIFEST_NAME: ${{ steps.manifest-name.outputs.name }}
      run: |
        # Build tag flags for manifest
        TAG_FLAGS=()

        echo "Processing additional tags..."
        while IFS= read -r tag; do
          # Skip empty lines and comments
          if [[ -z "$tag" || "$tag" =~ ^[[:space:]]*# ]]; then
            continue
          fi

          # Trim whitespace
          tag=$(echo "$tag" | xargs)

          # Validate tag format (Docker tag naming rules)
          if ! [[ "$tag" =~ ^[A-Za-z0-9_][A-Za-z0-9_.-]{0,127}$ ]]; then
            echo "::error::Invalid Docker tag format: '$tag'. Tags must start with a letter, number, or underscore and can only contain alphanumeric characters, underscores, periods, and hyphens (max 128 chars)."
            exit 1
          fi

          TAG_FLAGS+=("--tag" "${DOCKER_MANIFEST_NAME}:${tag}")
          echo "  Adding tag: ${tag}"
        done <<< "$ADDITIONAL_TAGS"

        # Convert array to space-separated string for output.
        TAG_FLAGS_STRING="${TAG_FLAGS[*]}"
        echo "tag-flags=${TAG_FLAGS_STRING}" | tee -a "${GITHUB_OUTPUT}"

    - name: Wait for source images to be available
      shell: bash
      env:
        DOCKER_MANIFEST_NAME: ${{ steps.manifest-name.outputs.name }}
        DOCKER_IMAGE_NAME_DIGESTS: ${{ inputs.docker-image-name-digests }}
        DOCKER_IMAGE_AVAILABILITY_CHECK:
          ${{ inputs.docker-image-availability-check }}
      run: |
        # Convert comma-separated list into array
        IFS=',' read -ra DIGESTS <<< "$DOCKER_IMAGE_NAME_DIGESTS"

        if [[ "${DOCKER_IMAGE_AVAILABILITY_CHECK}" == "true" ]]; then
          echo "Checking image availability before creating manifest..."

          MAX_RETRIES=5
          RETRY_DELAY=10
          ALL_AVAILABLE=false

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt ${attempt}/${MAX_RETRIES}: Checking image availability..."
            MISSING_IMAGES=()

            for digest in "${DIGESTS[@]}"; do
              # Trim whitespace from digest
              digest=$(echo "$digest" | xargs)
              IMAGE_WITH_DIGEST="${DOCKER_MANIFEST_NAME}@${digest}"

              if docker buildx imagetools inspect "${IMAGE_WITH_DIGEST}" >/dev/null 2>&1; then
                echo "  ‚úì ${digest} is available"
              else
                echo "  ‚è≥ ${digest} not yet available"
                MISSING_IMAGES+=("${digest}")
              fi
            done

            if [[ ${#MISSING_IMAGES[@]} -eq 0 ]]; then
              echo "‚úÖ All images are available!"
              ALL_AVAILABLE=true
              break
            else
              echo "‚ùå ${#MISSING_IMAGES[@]} image(s) still missing: ${MISSING_IMAGES[*]}"
              if [[ $attempt -lt $MAX_RETRIES ]]; then
                echo "Waiting ${RETRY_DELAY} seconds before next attempt..."
                sleep $RETRY_DELAY
              fi
            fi
          done

          if [[ "$ALL_AVAILABLE" != "true" ]]; then
            echo "::error::Failed to verify image availability after ${MAX_RETRIES} attempts"
            echo "::error::Missing images: ${MISSING_IMAGES[*]}"
            exit 1
          fi
        else
          echo "Image availability check disabled, using fixed delay..."
          echo "Waiting 30 seconds for source images to be fully available..."
          sleep 30
        fi

    - name: Create and push Docker manifest
      id: create-push-docker-manifest
      shell: bash
      env:
        DOCKER_MANIFEST_NAME: ${{ steps.manifest-name.outputs.name }}
        DOCKER_MANIFEST_TAG: ${{ inputs.docker-manifest-tag }}
        DOCKER_REGISTRY_URL: ${{ inputs.docker-registry-url }}
        DOCKER_REPOSITORY_NAME: ${{ inputs.docker-repository-name }}
        DOCKER_IMAGE_NAME_DIGESTS: ${{ inputs.docker-image-name-digests }}
        ANNOTATION_FLAGS:
          ${{ steps.generate-annotations.outputs.annotation-flags }}
        TAG_FLAGS: ${{ steps.process-additional-tags.outputs.tag-flags }}
      run: |
        DOCKER_MANIFEST_NAME_WITH_TAG="${DOCKER_MANIFEST_NAME}:${DOCKER_MANIFEST_TAG}"
        # Convert comma-separated list into array and pass as separate arguments
        IFS=',' read -ra DIGESTS <<< "$DOCKER_IMAGE_NAME_DIGESTS"
        # Map each digest to include the manifest name
        PREFIXED_DIGESTS=()
        for digest in "${DIGESTS[@]}"; do
          PREFIXED_DIGESTS+=("${DOCKER_MANIFEST_NAME}@${digest}")
        done

        # Create Docker manifest
        echo "Creating Docker manifest with tag: ${DOCKER_MANIFEST_TAG}"

        # Build the complete command with all flags
        CMD_ARGS=("--tag" "${DOCKER_MANIFEST_NAME_WITH_TAG}")

        # Add additional tag flags if present
        if [[ -n "${TAG_FLAGS}" ]]; then
          echo "Adding additional tags to manifest..."
          read -ra TAG_ARRAY <<< "${TAG_FLAGS}"
          CMD_ARGS+=("${TAG_ARRAY[@]}")
        fi

        # Add annotation flags if present
        if [[ -n "${ANNOTATION_FLAGS}" ]]; then
          echo "Adding annotations to manifest..."
          read -ra ANNOTATION_ARRAY <<< "${ANNOTATION_FLAGS}"
          CMD_ARGS+=("${ANNOTATION_ARRAY[@]}")
        fi

        # Add the source images (target images to tag).
        CMD_ARGS+=("${PREFIXED_DIGESTS[@]}")
        echo "::debug::Final docker buildx imagetools command arguments: ${CMD_ARGS[*]}"

        # Execute the command
        docker buildx imagetools create "${CMD_ARGS[@]}"

        # Get manifest digest (format: sha256:hash)
        MANIFEST_DIGEST=$(docker buildx imagetools inspect "${DOCKER_MANIFEST_NAME_WITH_TAG}" | grep -m1 'Digest:' | awk '{print $2}')
        echo "manifest-digest=${MANIFEST_DIGEST}" | tee -a "${GITHUB_OUTPUT}"
        echo "manifest-name=${DOCKER_MANIFEST_NAME}" | tee -a "${GITHUB_OUTPUT}"
        echo "manifest-name-with-digest=${DOCKER_MANIFEST_NAME}@${MANIFEST_DIGEST}" | tee -a "${GITHUB_OUTPUT}"
        echo "manifest-name-with-tag=${DOCKER_MANIFEST_NAME_WITH_TAG}" | tee -a "${GITHUB_OUTPUT}"

    - name: Install cosign
      if: inputs.docker-manifest-sign == 'true'
      uses: sigstore/cosign-installer@7e8b541eb2e61bf99390e1afd4be13a184e9ebc5 # v3.10.1
      with:
        cosign-release: "v2.4.2"

    - name: Sign Docker Manifest using GH OIDC
      if: inputs.docker-manifest-sign == 'true'
      shell: sh
      env:
        MANIFEST_NAME_WITH_DIGEST:
          ${{
          steps.create-push-docker-manifest.outputs.manifest-name-with-digest }}
      run: cosign sign "${MANIFEST_NAME_WITH_DIGEST}" --yes

    - name: Verify Docker image signature
      if:
        inputs.docker-manifest-sign == 'true' &&
        inputs.cosign-oidc-identity-regexp != ''
      shell: sh
      env:
        MANIFEST_NAME_WITH_DIGEST: >-
          ${{
            steps.create-push-docker-manifest.outputs.manifest-name-with-digest
          }}
        GITHUB_WORKFLOW_REPOSITORY: ${{ inputs.github-workflow-repository }}
        OIDC_ISSUER: ${{ inputs.cosign-oidc-issuer }}
        OIDC_IDENTITY_REGEXP: ${{ inputs.cosign-oidc-identity-regexp }}
      run: |
        cosign verify "${MANIFEST_NAME_WITH_DIGEST}" \
          --certificate-oidc-issuer "${OIDC_ISSUER}" \
          --certificate-identity-regexp "${OIDC_IDENTITY_REGEXP}" \
          --certificate-github-workflow-repository "${GITHUB_WORKFLOW_REPOSITORY}"

    - name: Summary output
      shell: bash
      env:
        DOCKER_MANIFEST_SIGNED: ${{ inputs.docker-manifest-sign }}
        GITHUB_WORKFLOW_REPOSITORY: ${{ inputs.github-workflow-repository }}
        MANIFEST_ADDITIONAL_TAGS:
          ${{ steps.create-push-docker-manifest.outputs.manifest-additional-tags
          }}
        MANIFEST_DIGEST:
          ${{ steps.create-push-docker-manifest.outputs.manifest-digest }}
        MANIFEST_NAME:
          ${{ steps.create-push-docker-manifest.outputs.manifest-name}}
        MANIFEST_NAME_WITH_DIGEST: >-
          ${{
            steps.create-push-docker-manifest.outputs.manifest-name-with-digest
          }}
        MANIFEST_NAME_WITH_TAG: >-
          ${{
            steps.create-push-docker-manifest.outputs.manifest-name-with-tag
          }}
        MANIFEST_TAG: ${{ inputs.docker-manifest-tag }}
        OIDC_ISSUER: ${{ inputs.cosign-oidc-issuer }}
        OIDC_IDENTITY_REGEXP: ${{ inputs.cosign-oidc-identity-regexp }}
      run: |
        echo "### Docker Manifest üìí" | tee -a "${GITHUB_STEP_SUMMARY}"
        echo >> "${GITHUB_STEP_SUMMARY}"
        echo "Manifest digest: \`${MANIFEST_DIGEST}\`" | tee -a "${GITHUB_STEP_SUMMARY}"
        echo "Manifest name: \`${MANIFEST_NAME}\`" | tee -a "${GITHUB_STEP_SUMMARY}"
        echo "Manifest tag: \`${MANIFEST_TAG}\`" | tee -a "${GITHUB_STEP_SUMMARY}"
        echo "Manifest additional tags: \`${MANIFEST_ADDITIONAL_TAGS:-None}\`" | tee -a "${GITHUB_STEP_SUMMARY}"
        echo "Manifest name with tag: \`${MANIFEST_NAME_WITH_TAG}\`" | tee -a "${GITHUB_STEP_SUMMARY}"
        echo "Manifest name with digest: \`${MANIFEST_NAME_WITH_DIGEST}\`" | tee -a "${GITHUB_STEP_SUMMARY}"
        if [[ "${DOCKER_MANIFEST_SIGNED}" == 'true' ]]; then
          echo >> "${GITHUB_STEP_SUMMARY}"
          echo "#### Docker Manifest signed üìù" | tee -a "${GITHUB_STEP_SUMMARY}"
          echo "Manifest signed with cosign. To verify, run:" | tee -a "${GITHUB_STEP_SUMMARY}"
          echo "\`\`\`shell" >> "${GITHUB_STEP_SUMMARY}"
          echo "cosign verify ${MANIFEST_NAME_WITH_DIGEST} --certificate-oidc-issuer ${OIDC_ISSUER} --certificate-identity-regexp '${OIDC_IDENTITY_REGEXP}' --certificate-github-workflow-repository ${GITHUB_WORKFLOW_REPOSITORY}" | tee -a "${GITHUB_STEP_SUMMARY}"
          echo "\`\`\`" >> "${GITHUB_STEP_SUMMARY}"
        fi
        echo >> "${GITHUB_STEP_SUMMARY}"
        echo "‚ö†Ô∏è **NOTE:** Above output may be masked if using private registries. You may need to fill in the blanks." | tee -a "${GITHUB_STEP_SUMMARY}"
